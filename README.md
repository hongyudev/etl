# Code Overview
The code reads a csv file, masks sensitive fields, and stores the results into a database.
When masking, the original value is copied and encrypted in a new column, so the data is not lost (rewriter.py). AES GCM mode is the encryption algorithm. Nonce used during encrpython does not need to be kept secret, so it is prepended to the encrypted value and stored in the same column to simply the db schema. Any decrypter needs to know this implementation detail to decrypt correctly.

Under the src/ directory:
1. main.py contains the main function. It contains the mapping of column names to the rewriting function, if applicable, as well as the defined sensitive data categories (class Environment). It also contains util functions to prepare the encryption key. 
2. rewriter.py contains the util functions to rewrite/mask values, which are potentially reused across columns.
3. load.py contains the implementation to write the processed data into database. Only sqllite is implemented at the moment.
4. constant.py contains predefined constants to reuse to make the code cleaner.


# Instructions to Run Code
## Prerequisite
The code was developed to run on MacOS. Python 3.10 is the intepreter. pip3 is needed to install needed packages. Also, sqlite3 is needed to run on the local machine (which MacOS supports by default).
## Instructions
`./run.sh [data csv file] [encryption key file]`

If the encryption key file does not exist, a new key will be generated and written to the file.

After running run.sh, a db file test_db.db will be created in the current directory. To check the raw contents in the db, run the following in the same directory:
`python read_db.py`

# Assumptions and Trade-offs
1. Assumed the data size is small enough to handle on the local laptop. This is to limit the complexity of the solution.
2. Assumed the data schema is defined by the first row in the csv file, and that new csv files conform to the same format.
3. Assumed the `id` column is the primary key that is unique in the dataset.
4. Only limited input validation is implemented to limit the complexity of the solution. For example: key file's path must be well formed. `id` in the csv file must be unique. IPv6 is not handled. Validity of CC numbers, phone numbers, emails, countries, etc., is not checked.
5. Encryption key is generated by the same program that runs the data processing. This is to simplify the solution, and will never happen in production, where proper integration with KMS, e.g., HashiCorp Vault, should be done.
6. The column that stores the masked value and the column that stores the encrypted raw value are in the same table. Such schema is more efficient when reading, compared to storing the columns in separate tables.
7. sqlite is used in the solution for simplicity. In real-world applications, a DB that supports column based access control, e.g., Google's cloud spanner, is needed. Some users can access the raw data, while others can only access the masked data.
